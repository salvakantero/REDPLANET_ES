// msc.h
// Generated by Mojon Script Compiler v3.97 20191202 from MT Engine MK1 v5.0+
// Copyleft 2015 The Mojon Twins

#ifdef CLEAR_FLAGS
void msc_init_all (void) {
    for (sc_c = 0; sc_c < MAX_FLAGS; ++ sc_c)
        flags [sc_c] = 0;
}
#endif

unsigned char read_byte (void) {
    #asm
            ld  hl, (_script)
            ld  a, (hl)
            ld  (_safe_byte), a
            inc hl
            ld  (_script), hl
    #endasm
    return safe_byte;
}

unsigned char read_vbyte (void) {
    #asm
        call _read_byte
        ld  a, l
        and 128
        ret z
        ld  a, l
        and 127
        ld  c, a
        ld  b, 0
        ld  hl, _flags
        add hl, bc
        ld  l, (hl)
        ld  h, 0
        ret
    #endasm
}

void readxy (void) {
    sc_x = read_vbyte ();
    sc_y = read_vbyte ();
}

void stop_player (void) {
    p_vx = p_vy = 0;
}

void reloc_player (void) {
    p_x = read_vbyte () << (4+FIXBITS);
    p_y = read_vbyte () << (4+FIXBITS);
    stop_player ();
}

void read_two_bytes_D_E (void) {
    #asm
            // Read two bytes: flag #, number


                ld  hl, (_script)
                ld  d, (hl)         // flag #
                inc hl
                ld  e, (hl)         // number
                inc hl
                ld  (_script), hl

    #endasm
}
unsigned char *next_script;
void run_script (unsigned char whichs) {

    // main_script_offset contains the address of scripts for current level
    asm_int = main_script_offset + whichs + whichs;
#ifdef DEBUG
    debug_print_16bits (0, 23, asm_int);
#endif


    #asm
        ld hl, (_asm_int)
        ld a, (hl)
        inc hl
        ld h, (hl)
        ld l, a
        ld  (_script), hl
    #endasm


#ifdef DEBUG
    debug_print_16bits (5, 23, (unsigned int) script);
#endif

    if (script == 0)
        return;

    script += main_script_offset;
#ifdef DEBUG
    debug_print_16bits (10, 23, (unsigned int) script);
#endif


    while ((sc_c = read_byte ()) != 0xFF) {
        next_script = script + sc_c;
        sc_terminado = sc_continuar = 0;
        while (!sc_terminado) {
            switch (read_byte ()) {
                case 0x10:
                    // IF FLAG sc_x = sc_n
                    // Opcode: 10 sc_x sc_n
                    // readxy ();
                    // sc_terminado = (flags [sc_x] != sc_y);
                    #asm
                            call _read_two_bytes_d_e
                            // Set sc_terminado if flags [C] != E
                            ld  b, 0
                            ld  c, d
                            ld  hl, _flags
                            add hl, bc
                            ld  a, (hl)
                            cp  e
                            jr  z, _flag_equal_val_ok
                            ld  a, 1
                            ld  (_sc_terminado), a
                        ._flag_equal_val_ok
                    #endasm
                    break;
                case 0x21:
                    // IF PLAYER_IN_X x1, x2
                    // Opcode: 21 x1 x2
                    sc_x = read_byte ();
                    sc_y = read_byte ();
                    sc_terminado = (!((p_x >> FIXBITS) >= sc_x && (p_x >> FIXBITS) <= sc_y));
                    break;
                case 0x22:
                    // IF PLAYER_IN_Y y1, y2
                    // Opcode: 22 y1 y2
                    sc_x = read_byte ();
                    sc_y = read_byte ();
                    sc_terminado = (!((p_y >> FIXBITS) >= sc_x && (p_y >> FIXBITS) <= sc_y));
                    break;
                case 0x41:
                     // IF OBJECT_COUNT = sc_n
                     // Opcode: 41 sc_n
                     sc_terminado = (p_objs != read_vbyte ());
                     break;
                case 0xF0:
                     // IF TRUE
                     // Opcode: F0
                     break;
                case 0xFF:
                    // THEN
                    // Opcode: FF
                    sc_terminado = 1;
                    sc_continuar = 1;
                    break;
            }
        }
        if (sc_continuar) {
            sc_terminado = 0;
            while (!sc_terminado) {
                switch (read_byte ()) {
                    case 0x01:
                        // SET FLAG sc_x = sc_n
                        // Opcode: 01 sc_x sc_n
                        #asm
                                call _readxy
                                ld  de, (_sc_x)
                                ld  d, 0
                                ld  hl, _flags
                                add hl, de
                                ld  a, (_sc_y)
                                ld  (hl), a
                        #endasm
                        break;
                    case 0xE0:
                        // SOUND sc_n
                        // Opcode: E0 sc_n
#ifdef MODE_128K
                        wyz_play_sound (read_vbyte ());
#else
                        beep_fx (read_vbyte ());
#endif
                        break;
                    case 0xF1:
                        // WIN
                        script_result = 1;
                        return;
                    case 0xF4:
                        // DECORATIONS
                        #asm
                               ld  hl, (_script)
                               call _draw_decorations_loop
                               inc hl
                               ld  (_script), hl
                        #endasm
                        break;
                    case 0xFF:
                        sc_terminado = 1;
                        break;
                }
            }
        }
        script = next_script;
    }
}
